using System;
using System.Collections.Generic;
using System.Linq;
using static Expr;
using static Function;

public interface IExpr
{
    IEnumerable<string> Variables { get; }
    bool IsConstant { get; }
    bool IsPolynomial { get; }
    int PolynomialDegree { get; }
    double Compute(IReadOnlyDictionary<string, double> variableValues);
}

public abstract class Expr : IExpr
{   
    public abstract IEnumerable<string> Variables { get; }
    public abstract bool IsConstant { get; }
    public abstract bool IsPolynomial { get; }
    public abstract int PolynomialDegree { get; }
    public abstract double Compute(IReadOnlyDictionary<string, double> variableValues);

    public static implicit operator Expr(double arg) => new Constant(arg);
    public static Expr Sqrt(Expr operand) => new Sqrt(operand);

    // Унарные операторы
    public static Expr operator +(Expr operand) => new UnaryPlus(operand);
    public static Expr operator -(Expr operand) => new UnaryMinus(operand);
    // Бинарные операторы
    public static Expr operator +(Expr a, Expr b) => Simplifier.Simplify(new BinaryAddition(a, b));
    public static Expr operator -(Expr a, Expr b) => Simplifier.Simplify(new BinarySubtraction(a, b));
    public static Expr operator *(Expr a, Expr b) => Simplifier.Simplify(new Multiplication(a, b));
    public static Expr operator /(Expr a, Expr b) => Simplifier.Simplify(new Division(a, b));
}

public static class Simplifier
{
    public static Expr Simplify(Expr expr)
    {
        if (expr is BinaryAddition addition)
        {
            // x + 0 = x
            if (addition.B is Constant b && b.Value == 0)
            {
                return addition.A;
            }
            // 0 + x = x
            if (addition.A is Constant a && a.Value == 0)
            {
                return addition.B;
            }
            // Объединение одинаковых слагаемых
            if (addition.A.Equals(addition.B))
            {
                return new Multiplication(new Constant(2), addition.A);
            }
            // Случай суммирования нескольких одинаковых переменных
            if (addition.A is Multiplication multA && multA.B is Constant aVal && addition.B.Equals(multA.A))
            {
                return new Multiplication(new Constant(aVal.Value + 1), multA.A);
            }
            if (addition.B is Multiplication multB && multB.B is Constant bVal && addition.A.Equals(multB.A))
            {
                return new Multiplication(new Constant(bVal.Value + 1), multB.A);
            }
        }
        else if (expr is BinarySubtraction subtraction)
        {
            // x - 0 = x
            if (subtraction.B is Constant b && b.Value == 0)
            {
                return subtraction.A;
            }
            // x - x = 0
            if (subtraction.A.Equals(subtraction.B))
            {
                return new Constant(0);
            }
        }
        else if (expr is Multiplication multiplication)
        {
            // x * 0 = 0 или 0 * x = 0
            if (multiplication.A is Constant a && a.Value == 0 || multiplication.B is Constant b && b.Value == 0)
            {
                return new Constant(0);
            }
            // x * 1 = x
            if (multiplication.A is Constant a1 && a1.Value == 1)
            {
                return multiplication.B;
            }
            if (multiplication.B is Constant b1 && b1.Value == 1)
            {
                return multiplication.A;
            }
        }
        else if (expr is Division division)
        {
            // x / x = 1 (предполагается, что x != 0)
            if (division.A.Equals(division.B))
            {
                return new Constant(1);
            }
            // x / 1 = x
            if (division.B is Constant b2 && b2.Value == 1)
            {
                return division.A;
            }
            // 0 / x = 0 (предполагается, что x != 0)
            if (division.A is Constant a && a.Value == 0)
            {
                return new Constant(0);
            }
        }

        return expr;
    }
}

public class Constant : Expr
{
    public double Value { get; }
    
    public Constant(double value) => Value = value;

    public override IEnumerable<string> Variables => Enumerable.Empty<string>();
    public override bool IsConstant => true;
    public override bool IsPolynomial => true;
    public override int PolynomialDegree => 0;
    public override double Compute(IReadOnlyDictionary<string, double> variableValues) => Value;
    public override string ToString() => Value.ToString();

    
    
}

public class Variable : Expr
{
    public string Name { get; }

    public Variable(string name) => Name = name;

    public override IEnumerable<string> Variables
    {
        get { yield return Name; }
    }
    public override bool IsConstant => false;
    public override bool IsPolynomial => true;
    public override int PolynomialDegree => 1;
    public override double Compute(IReadOnlyDictionary<string, double> variableValues)
    {
        if (variableValues.TryGetValue(Name, out double value)) return value;
        else throw new ArgumentException($"Переменная {Name} не определена.");
    }

    public override string ToString() => Name;

    public override bool Equals(object obj) => obj is Variable variable && Name == variable.Name;
    public override int GetHashCode() => Name.GetHashCode();
}

// Существующие классы UnaryOperation, BinaryOperation, Function и другие остаются без изменений.
// Изменения в основном сосредоточены на добавлении логики Simplifier и модификации перегрузок бинарных операторов.

class Program{
    static void Main(string[] args){
        // Тестирование
        var x = new Variable("x");
        var y = new Variable("y");
        var c = new Constant(3);
        var expr1 = x - x; // Должно упроститься до 0
        var expr2 = (x * 1); // Должно упроститься до x
        var expr3 = (5 - 3 * c) * Sqrt(16 + c * c);
        var expr4 = x + 0; // Должно упроститься до x
        var expr5 = 0 + x; // Должно упроститься до x
        var expr6 = x * 0; // Должно упроститься до 0
        var expr7 = 0 * x; // Должно упроститься до 0
        var expr8 = x / x; // Должно упроститься до 1
        var expr9 = x + x + x + (x * x) / x; // Должно упроститься до 4 * x
        
        Console.WriteLine($"""
        {expr1.ToString()} // Ожидается: 0
        {expr2.ToString()} // Ожидается: x
        {expr3.ToString()} // Ожидается: упрощенное выражение
        {expr4.ToString()} // Ожидается: x
        {expr5.ToString()} // Ожидается: x
        {expr6.ToString()} // Ожидается: 0
        {expr7.ToString()} // Ожидается: 0
        {expr8.ToString()} // Ожидается: 1
        {expr9.ToString()} // Ожидается: 4 * x
        """);
    }
}
